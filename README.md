# I2C/IIC/I²C-VHDL-Model
This is my Final year project, it consists on developping a VHDL Model of the I2C Bus.
We are going to start this project with defining the different components, functionalities, specificities and drivers that need to be considered while creating the models.
## I2C-Bus: What’s that?
The I2C bus was designed to allow easy communication between components (low-speed devices like microcontrollers, EEPROMs, A/D and D/A converters, I/O interfaces and other similar peripherals in embedded systems) which reside on the same circuit board.  
![FACV3E9JK10S48J LARGE](https://user-images.githubusercontent.com/35849581/69913430-6ac55080-1440-11ea-91ee-bdce19c7cfd2.jpg)  
I2C Bus is easy to use, most significant features are:  
 * Only 2 wires with pull-up resistors are needed to connect unlimited number of I2C devices:  
      1.SDA: Serial Data line controlled by Master and Slave  
      2.SCL: Serial Clock generated by Master.  
      Both SDA and SCL are open drained (made of a transistor with no connection on top. Without external circuitry they can't really be         used).
      SDA must be pulled up to VCC with a 5.6-kilo-ohm resistor and SCL also needs to be pulled up with the same resistor only if there         are multiple masters in the system or when the slave want to synchronise with the master.
 * Synchronous , bidirectional and Half duplex.
 * A true multi-master and multi-slave bus.  
 * Each device connected to the bus is software-addressable by a unique address.    
 ## Communication Mode ( Baude Rate)  
  * Slow Mode: 100Kb/sec  
  * Fast Mode: 400Kb/sec  
  * High Speed Mode: 3.4Mbit/sec  
  * Fast Mode Plus 1Mhz  
  * Ultra Fast Mode 5Mhz ( is no real I2C).  
 ## Establishing Connection
 Write operation:  
1. Initialize I2C.
2. Generate START condition.
3. Send Slave device write address (SLA+W) and check for acknowledgement.
4. Write memory location address for memory devices to which we want to write.
5. Write data till last byte.
6. Generate STOP condition.
Read operation:  
1. Initialize I2C.
2. Generate START condition.
3. Write device Write address (SLA+W) and check for acknowledgement.
4. Write memory location address for memory devices.
5. Generate REPEATED START condition with (SLA +R).
6. Read data and return acknowledgement.
7. Return Not acknowledgement for last byte.
8. Generate STOP condition.  
![528_Fig_3](https://user-images.githubusercontent.com/35849581/70900258-1fdf3780-2001-11ea-92c5-db26d3b7b671.jpg)  
Prior to any transmission, a start condition needs to be issued on the bus. The start condition acts as a signal to all connected ICs that something is about to be transmitted on the bus. It is initiated by the master by sending a high-to-low transition on the SDA line whilst SCL is high as shown below  
![Z3F_Fig_2](https://user-images.githubusercontent.com/35849581/70900898-6aad7f00-2002-11ea-9c9c-6cc36bed86d1.jpg)  
After the start condition, the 7-bit slave address followed by the eighth bit is sent on the SDA line by the master, where a ‘0’ on bit indicates a write operation from the master to the slave (master is the transmitter and slave is the receiver) and a ‘1’ indicates a read operation from the slave to the master (master is the receiver and slave is the transmitter).  
The MSB of the address bits is sent first followed by the other bits. The value on the SDA line can be changed when SCL line is low.    
The slave device whose address is the same as the address being sent out by the master responds with an acknowledgement bit on the SDA line by pulling the SDA line low during the ninth clock cycle of the SCL line.  
After that, the transmission takes place between the master and the slave. Each byte on the SDA line for transmission is 8 bits long with the MSB being sent first.  
Also, the SDA line must not be changed when SCL line is high, except for the start and the stop conditions.  
Any number of bytes can be transmitted, however each byte is to be followed by an acknowledgement bit.   
## I²C master controller implementation
In this section, the implementation of the I²C master controller using an FPGA is discussed:  
I²C master controller in an FPGA will be implemented using a finite state machine (FSM).  
 FSMs can be classified as Mealy FSM and Moore FSM. In a Mealy FSM, the output depends on the current input and the current state  whereas in a Moore FSM, the output depends on the current state only.  
 


